from bson import ObjectId
from pydantic_core import core_schema
from pydantic import BaseModel, Field, GetCoreSchemaHandler, field_validator
from typing import Any, Union, Optional, Literal
import datetime

class PydanticObjectId(ObjectId):
    @classmethod
    def __get_pydantic_core_schema__(cls, _source_type: Any, _handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:
        return core_schema.no_info_after_validator_function(
            cls.validate,
            core_schema.union_schema([
                core_schema.str_schema(),
                core_schema.is_instance_schema(ObjectId),
            ])
        )

    @classmethod
    def validate(cls, value: Any) -> ObjectId:
        if isinstance(value, ObjectId):
            return value
        if isinstance(value, str) and ObjectId.is_valid(value):
            return ObjectId(value)
        raise ValueError(f"Invalid ObjectId: {value}")

class RenameCollectionRequest(BaseModel):
    """The request body for renaming a collection."""
    newName: str = Field(..., min_length=1, max_length=100)

class CollectionOut(BaseModel):
    id: PydanticObjectId = Field(alias="_id")
    userId: PydanticObjectId
    name: str
    totalChars: int = Field(default=0, description="Total character count of all content in the collection.")
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    class Config: json_encoders = {ObjectId: str}; populate_by_name = True

class FileInfo(BaseModel):
    filename: str
    format: str
    size: int
    location: str
    suffix: Optional[str] = None

class ContentOut(BaseModel):
    id: PydanticObjectId = Field(alias="_id")
    userId: PydanticObjectId
    collectionId: PydanticObjectId
    sourceType: str
    fileInfo: FileInfo
    checksum: str
    uploadedAt: datetime.datetime

    class Config:
        json_encoders = {ObjectId: str}
        populate_by_name = True

class ChatMessage(BaseModel):
    """Represents a single message in the chat history."""
    role: str
    content: str
    timestamp: datetime.datetime = Field(default_factory=lambda: datetime.datetime.now(datetime.timezone.utc))

class DocumentChatRequest(BaseModel):
    """The request body for chatting with a single document. The client MUST provide a session_id."""
    query: str
    session_id: str

class ChatSessionOut(BaseModel):
    """Represents the entire chat session document."""
    id: PydanticObjectId = Field(alias="_id")
    collectionId: PydanticObjectId
    userId: PydanticObjectId
    messages: list[ChatMessage]
    status: str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    class Config:
        json_encoders = {ObjectId: str}
        populate_by_name = True

class Question(BaseModel):
    """A simple model for generating a single question string."""
    question: str

class TeachMeBackAnswerRequest(BaseModel):
    """The user's answer to the 'Teach Me Back' question."""
    answer: str = Field(..., min_length=10, description="The user's explanation in their own words.")

class TeachMeBackEvaluation(BaseModel):
    """Represents the AI's evaluation of the user's explanation."""
    feedback: str = Field(description="Constructive feedback for the user.")
    accuracy_score: float = Field(description="A score from 0.0 (incorrect) to 1.0 (perfect).")
    missed_points: list[str] = Field(description="Key concepts from the source text that the user missed.")
    incorrect_points: list[str] = Field(description="Parts of the user's answer that were factually incorrect.")

class TeachMeBackData(BaseModel):
    """
    Represents the data for a 'Teach Me Back' reinforcement item.
    """
    # --- THIS IS THE FIX ---
    type: Literal["teachMeBack"] = "teachMeBack"
    # ----------------------
    question: str = Field(description="The question generated by the AI.")
    context: str = Field(description="The source text used for generation and evaluation.")
    user_answer: Optional[str] = Field(None, description="The user's submitted explanation.")
    evaluation: Optional[TeachMeBackEvaluation] = Field(None, description="The AI's feedback on the user's answer.")

class TeachMeBackQuestionRequest(BaseModel):
    """Request for generating the question."""
    difficulty: str

    @field_validator('difficulty')
    def difficulty_must_be_valid(cls, v: str) -> str:
        if v not in ["easy", "medium", "hard"]:
            raise ValueError("Difficulty must be 'easy', 'medium', or 'hard'")
        return v

class ChatRequest(BaseModel):
    """The request body for sending a new chat message."""
    query: str

class RenameSourceRequest(BaseModel):
    """The request body for renaming a source document."""
    newName: str

class YoutubeRequest(BaseModel):
    """The request body for adding a new YouTube source."""
    url: str

class GenerationRequest(BaseModel):
    """Request body for generating items like MCQs, Quizzes, and Flashcards."""
    difficulty: str
    numberOfItems: int = Field(10, gt=0)

    @field_validator('difficulty')
    def difficulty_must_be_valid(cls, v: str) -> str:
        if v not in ["easy", "medium", "hard"]:
            raise ValueError("Difficulty must be 'easy', 'medium', or 'hard'")
        return v
    
    @field_validator('numberOfItems')
    def number_must_be_reasonable(cls, v: int) -> int:
        if v > 50:
            raise ValueError("Number of items cannot exceed 50.")
        return v

class MindMapNode(BaseModel):
    topic: str; children: list['MindMapNode'] = Field(default_factory=list)
MindMapNode.model_rebuild()

class MindMap(BaseModel):
    type: Literal["mindMap"] = "mindMap"
    roots: list[MindMapNode]

class MCQ(BaseModel):
    type: Literal["mcq"] = "mcq"
    question: str; options: list[str] = Field(min_length=4, max_length=4)
    correctAnswer: str

class MCQSet(BaseModel):
    type: Literal["mcqSet"] = "mcq"
    mcqs: list[MCQ]

class TrueFalseQuestion(BaseModel):
    type: Literal["true_false"] = "true_false"
    question: str; correctAnswer: bool

class ShortAnswerQuestion(BaseModel):
    type: Literal["short_answer"] = "short_answer"
    question: str; idealAnswer: str

class Flashcard(BaseModel):
    type: Literal["flashcard"] = "flashcard"
    front: str = Field(description="The front of the card, showing a question or a term.")
    back: str = Field(description="The back of the card, showing the answer or definition.")

AnyQuizQuestion = Union[MCQ, TrueFalseQuestion, ShortAnswerQuestion]

class QuizSet(BaseModel):
    type: Literal["quiz"] = "quiz"
    questions: list[AnyQuizQuestion]

class FlashcardSet(BaseModel):
    type: Literal["flashcardSet"] = "flashcardSet"
    flashcards: list[Flashcard]

ReinforcementData = Union[MindMap, MCQSet, QuizSet, FlashcardSet, TeachMeBackData]

class ReinforcementItemOut(BaseModel):
    id: PydanticObjectId = Field(alias="_id")
    type: str
    sourceType: str
    collectionId: PydanticObjectId
    userId: PydanticObjectId
    data: ReinforcementData = Field(..., discriminator='type')
    difficulty: Optional[str] = None
    createdAt: datetime.datetime
    class Config: 
        json_encoders = {ObjectId: str}
        populate_by_name = True

class Summary(BaseModel):
    """A model for a generated document summary."""
    type: Literal["summary"] = "summary"
    text: str = Field(description="The generated summary of the document.")

class DocumentAnalysisData(BaseModel):
    # This is a placeholder for the Union, the discriminator is on the parent
    pass

DocumentAnalysisData = Union[MindMap, Summary]

class DocumentAnalysisOut(BaseModel):
    id: PydanticObjectId = Field(alias="_id")
    type: str
    contentId: PydanticObjectId
    userId: PydanticObjectId
    collectionId: PydanticObjectId
    data: DocumentAnalysisData = Field(..., discriminator='type')
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    class Config:
        json_encoders = {ObjectId: str}
        populate_by_name = True

class NotificationPreferences(BaseModel):
    """Pydantic model for user notification settings."""
    enabled: bool
    frequency: Literal["daily", "weekly"]
    time: str  # Assuming HH:MM format

class UserPreferences(BaseModel):
    """Pydantic model for user learning preferences."""
    pacing: Literal["fast", "balanced", "relaxed"]
    preferredStudyTime: Literal["morning", "evening", "flexible"]
    notifications: NotificationPreferences

class UserOut(BaseModel):
    """The response model for returning a user's account details."""
    id: PydanticObjectId = Field(alias="_id")
    name: str
    email: str
    preferences: UserPreferences
    status: Literal["active", "archived", "deleted"]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    class Config:
        json_encoders = {ObjectId: str}
        populate_by_name = True
